		#if 1   //啥也不是

//第一步定义gpio初始化结构体
			gpio_pin_config_t GPIO_config;
			IOMUXC_SetPinMux(
			IOMUXC_GPIO_AD_B1_00_GPIO1_IO16,      
			0U); 
			IOMUXC_SetPinMux(
			IOMUXC_GPIO_AD_B1_01_GPIO1_IO17,      
			0U); 
			
			//GPIO配置      
			GPIO_config.direction = kGPIO_DigitalOutput; //输出模式
			GPIO_config.outputLogic =  1;                //默认低电平输出    
			GPIO_config.interruptMode = kGPIO_NoIntmode; //不使用中断
			
			
			//初始化GPIO
			GPIO_PinInit(GPIO1, 16, &GPIO_config);
						GPIO_PinInit(GPIO1, 17, &GPIO_config);
			GPIO_PinWrite(GPIO1,16,1);//J11  68
						GPIO_PinWrite(GPIO1,17,1);//K11  68
			
			
#endif	//	
		/************** C 语言 *******************/
1.数据类型: 
   数值类型: _Bool , char    1个字节
                  short 2字节
                  int 4字节   long  4或8字节

   符号:     区别(首位当成符号位)
	unsigned 无符号
	signed 有符号(默认)
                  
   浮点类型: (单精度) float       4字节   
                  (双进度) double   8字节 

   指针类型: *void (空类型)
   结构类型:
                 struct 结构体           ->   位域
                 enum 枚举
                 union 联合体

2.运算符
   算术运算符: + , - , * , / , %
   逻辑运算符: && ， || ， ！
   关系运算符: > , < , == , != , >= , <= 
   赋值运算符: =,+= , -= , *= , /= , %=
   位运算符: & , | , ^, ! ,<< , >> , ~      
	signed 有符号的<<,>>，注意事项: 1. << 地位默认补 0   ； 2. >> 高位默认补符号位(正0,负1)
   三元运算符:      条件? 真值:假值 
   
   面试前自行查看运算符优先级: ()最高, 而逗号最低 

3.分支语句 if else 以及 switch

4.循环语句 while 和 do while 以及 for

5.标签语句 goto

6.存储类型:       存储类型 数据类型 变量名;
     auto:自动推导类型（有无符号）
     register:寄存器类型 (建议性)
     static:静态类型 -> 只能在本源文件下使用 , 做到防止外部调用，在多源文件的时候可以使函数名重名而不报错
         1.静态变量（全局 和 局部）： 在编译时进行分配空间所以它只初始化1次
         2.静态函数
     extern:外部访问类型   -> 
	1. 想要其他源文件相互调用变量或者函数的时候可以使用 extern 做声明
 	2. 当 C 和 C++ 文件同时联编的时候可以使用 extern "C" 去做 C函数的声明

7.常量类型
   1.整数常量 :   后缀是 U(无符号) 和 L(长型) 的组合
	八进制: 070;
	十进制: 19;
	十六进制: 0x10;
   2.浮点常量： 浮点常量由整数部分、小数点、小数部分和指数部分组成 , 后缀是f
	小数形式： 3.1415
	指数 e(科学技术法):  3.14e
	
   注意事项: （整数）15 , (浮点数)15f

   3.字符常量： ASCII码值
   4.字符串常量：在C语言中,字符串结尾使用 '\0'表示,使用双引号括起来
	注意:拓展知识点,对字符数组的读写
		写: sprintf
		读: sscanf
	
   5.定义常量
	#define    定义常量
  	const 	定义常型变量

8.动态内存分配(堆区): 
           空间分配规则
	栈:由系统自动申请,自动释放
	堆:由程序员手动申请,手动释放
	    1.申请后未释放:内存泄漏
	    2.多次释放:段错误 
	    3.释放了栈空间
           申请函数:void *malloc(int num); 
           释放函数:void free(void *address);

数据清理函数: void *memset(void *str, int c, size_t n)   和 void bzero（void *s, int n）；


/******************* 数据结构 ***************************/
	线性 和 非线性
1.数组 : 
	优点:访问速度快,可以支持随机访问
	缺点:指定大小不可变,增删效率低
2.链表 :  通过指针域的方式,提高他的效率
	优点:大小可变,增删效率高(只需要更改指向)
	缺点:不支持随机访问,访问效率低
3.栈: 先进后出,后进先出
4.队列: 先进先出,后进后出
5.树：
	优点:结合了 数组 和 链表的优点，所以他在数据结构中占有一席之地
	各大数据库都是使用了树结构进行设计(平衡树 和 红黑树 以及 哈夫曼树 )
/******************* 算法 *******************************/
查找 : 
排序 : 
	冒泡排序: 
		算法步骤:  比较相邻的元素。如果第一个比第二个大，就交换他们两个。
			对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
			针对所有的元素重复以上的步骤，除了最后一个。
			持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
		优点: 当数据已经排好序 或者 只有少量数据排序的时候他的速度是最快的
		缺点: 当数据是反序的时候,他的效率非常低 
	快速排序:
		算法步骤:  1．先从数列中取出一个数作为基准数。
			2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
			3．再对左右区间重复第二步，直到各区间只有一个数。

		优点: 使用准基数作为分区,可以对小数据进行快速排序
		缺点: 但是当数据量过大的时候,可能会出现,排序错误

/****************** 系统编程 **************************/
1.Linux I/O 操作
2.Linux 文件操作
	1.C语言标准库文件
		FILE 句柄
		fopen 打开文件 ( r,w,a,+） -》 w,a当文件不存在的时候,自动创建
		fclose 关闭文件
		写: fwrite，fput，fprintf
		读: fread,fget,fgets,fscanf	
	     

	2.Linux标准库文件
		文件表述符: 普通文件,目录文件,管道文件,字符设备,块设备,管道文件,套接字,连接文件
		open()	打开
		close()	关闭
		read()	读取
		write()	写入
		ioctl(文件描述符,命令,命令结构体)	文件操作
	
3.多任务(进程/线程)
	/*************** 进程 *********************/
	进程状态: 新建 -> 就绪 -> 运行 -> 阻塞 -> 死亡
	1.fork() 创建进程 和 vfork() 创建进程 
		区别:fork() 父子进程调用随机
                                        vfor() 子进程先运行,直到子进程结束或者调用exce函数族
	2.wait() 和 waitpid() 规则子进程必须由父进程进行回收
		区别:wait()        默认阻塞回收
		        waitpid()  可以阻塞也可以非阻塞
			
	3.exit() 和 _exit()  
		区别:exit() 清空缓存区然后调用 sysexit()函数退出
		       _exit() 不清空缓存区直接调用sysexit()函数退出

	4.守护进程: 
		1.fork() 创建子进程
		2.exit()  父进程 父进程结束 , 使子进程变为一个孤儿进程
		3.setsid() 退出当前会话组
		4.chdir() 更改工作路径
		5.umask() 修改权限掩码
		6.close() / dup2()  关闭文件描述符 或则重定向
		7.dup2()    syslog错误描述放入到日志
	5.进程间通讯:
		1.管道 : fifo() 有名管道和 pipe()无名管道
			区别:无名管道用于亲缘进程,有名管道用于任意进程
			注意事项:1 支持半双工通讯,2 管道会炸裂
		2.信号:  signal(信号,信号处理函数)  ，kill 发送信号
		3.IPC机制:  键值 :      ftok(路径,低八位的数)得到Key值  ,可以使用 ipcs 指令进行查看
			1.消息队列: 
			2.共享内存:
			3.信号灯集:
		4.套接字
	
	/****************** 线程 *************************/
	1.创建:pthread_create()
	2.回收:pthread_join()   结合态,默认阻塞
	3.退出:pthraed_exit(); 
	4.线程状态: 结合态(默认,由进程回收) 和 分离态(由系统回收)
	5.线程通讯:
		1.信号量
		2.全局变量
		3.pthread_mutex 锁
		
线程和进行的区别：
	1.进程是系统资源分配的基本单位
	2.线程是CPU调用的最小单位
	3.一个进程至少拥有一个线程
	4.线程崩溃会影响到整个进程崩溃,子进程崩溃互补影响
	5.线程共享进程的内存空间,而进程间是相互独立的
	
使用情况:
	1.当需要高并发,且对数据安全性     较高的程序则使用进程
	2.当需要高并发,且对数据安全性要求不高的程序可使用线程,节省资源
	3.io复用 资源和效率更高，使用情况是 安全性不高且效率需求较高的情况

/*************************** 网络编程 *****************************/
TCP 和 UDP  , IP 
TCP/IP 七成模型			IOS 四层模型
	1.应用层				1.应用层
	2.会话层				2.传输层
	3.表示层				3.网络层 TCP 和 UDP
	4.网络层	TCP 和 UDP		4.物理层
	5.传输层	IP
	6.数据链路层
	7.物理层

/************************** TCP 和 UDP *************************/
    TCP服务器模型                                和                       TCP客户端模型
1.socket(SOCK_STREAM)创建套接字		1.socket()  创建套接字
2.bind()    绑定ip和端口（IPV4）		2.connect()连接服务器
3.listen()	监听				3.read()	  接收/write() 发送
4.accept()	等待响应				4.close()	  关闭套接字
5.read()	接收/write() 发送
6.close()	关闭套接字


    UDP服务器模型 		       和		    UDP客户端模型	
1.socket(SOCK_DGRAM)创建套接字		1.socket(SOCK_DGRAM)创建套接字
2.bind()    绑定ip和端口（IPV4）		2.recvfrom()接收 / 发送sendto()
3.recvfrom()接收 / 发送sendto()		3.close()	关闭套接字
4.close()	关闭套接字

/************************* TCP 和 UDP 特性 ************************/
TCP : 					UDP:
1.面向连接的				1.面向报文
2.可靠,安全的传输协议,流量控制			2.不需要建立连接,不可靠的连接,一对一,一对多,多对一的传输
3.一对一的传输,使用三次握手,四次挥手		3.应用场景:视频传输,直播会议等
4.应用场景:文件传输				4.优点:首部只有8字节,所以传输速度快
5.缺点: 最小首部 20字节，最大 60字节,速度慢		

/************************* sqlite3 数据库 ****************************/
SQL语句：语言使用SQL语句连接和处理数据库数据
数据库的优点是:
	1.冗余度小
	2.访问速度快:使用树形结构存储方式
	3.支持多任务访问，并有上锁机制


/************************* C++ ************************************/
1.三大特性: 封装 , 继承 ,多态
2.C++提供的动态内存分配关键字 new 和 delete
      malloc 与 new 的区别: malloc 只分配内存空间不自动调用构造函数进行初始化 , 而 new 既分配空间又调用构造函数进行初始化
      free  与 delete 的区别: free 只是单纯回收空间不自动调用析构函数,而 delete 既 回收空间 又 自动调用 析构函数释放指针成员所指向的堆空间
      关键字 与 函数 的区别: 函数需要创建函数栈 和 销毁函数栈,而关键字不用
3.命名空间 namespace：防止空间污染,做得变量名可以重名,使用 using 引入命名空间的方式使用变量名
4.C++ 模板 template : 函数模板 和 类模板 -> 使用模板化就可以定义统一的标准接口
5.STL标准模板容器：
	三大成员: 容器（Containers） , 算法（Algorithms),  迭代器（iterators）
	六大组件: 容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器
	主要的用的容器:
		Vector 向量（单端数组）:  不同之处在于数组是静态空间，而vector可以动态扩展,增删效率低，但是访问速度快
		string 字符串容器: 
		deque 双端数组: 使用了一个中控器,进行多区间的组合,所以它在增删上比vector要高,访问速度也比较快
		list 链表容器: 链表使用了指针域方式,所以它在增删的时候只需要更改指向即可，所以他的增删速度快,但是访问的时候必须遍历，所以他的访问速度慢
		stack 栈容器: 先进后出，后进先出，只可以访问顶部元素
		queue 队列容器:先进先出,后进后出,可以访问头部和尾部元素
		
		/******** 底层为二叉树的容器 ***********/
		set/ multiset 集合容器:存储的是单个元素,由于使用树的结构,所以它支持插入排序, set 支持去重, 而 multiset 可以拥有重复的元素
		map/ multimap字典容器:存储的是键值对元素,由于使用树的结构,所以它支持Key键值 插入排序map支持 Key键值 去重, multimap  可以拥有重复的Key值
			字典容器 与 结构数据中的JSON非常相似,所以在调用云平台的时候，通常使用的是JSON格式传输，所以可以使用其原理


封装: 将万物进行抽象化，抽象为类, 将他们的 属性 和 动作 进行封装
继承: 为了提高代码的复用性,可以通过继承方式,只维护新类的成员
多态: 不同的对象调用相同的接口，产生不同的结果

/**** 封装 ****/
权限:         
	公有权限: 类外 √     类内  √     派生  √
	保护权限: 类外 ×     类内  √     派生  √
	私有权限: 类外 ×     类内  √     派生  ×

struct 和 class 的区别:
	1. 默认权限：  struct  -> 公有  而  class  -> 私有
	2. 空类会使用1字节，让系统知道这个地址空间上存放这一个空类
	3. C语言的struct 是不允许拥有 成员函数的 ， 而 C++做了拓展，允许struct 提供这样的成员函数

构造函数   		---Vs---  			析构函数:
特点:						特点:
    1. 函数名与类型同名				1. 函数名与类型相同多了一个 ~ 号
    2. 没有返回值					2. 无参,无返回值，所以仅且只有一个析构函数(编辑器自动提供）
    3. 创建对象的时候自动调用				3. 在销毁对象的时候自动调用
函数类型:
1. 无参构造(编辑器自动提供)
2. 带参构造
       1. 普通带参
       2. 拷贝构造	
        	1.浅拷贝(编辑器自动提供)
    	2.深拷贝

static 静态成员:    
	特点 : 
		调用方法: 1.通过类名调用; 2.通过对象调用
		编译的时候就分配空间,所以他的空间是共用的
   1.静态成员属性:
	1. 类外初始化
   2.静态成员函数:
	1. 类外和类内都可以定义	
	2. 由于它在编译的时候就分配空间，所以不能调用类内普通成员,所以没有 this 

const 常量成员:
	特点: 无法被修改，且只能在定义时初始化
    1.常量成员属性:
	1. 初始化: 使用初始化列表进行初始化
                        {初始化列表经常用于 初始化(静态成员,构造函数)  ,  初始化的顺序与初始化列表没有任何关系,只与成员在类中声明的顺序和继承有关}
    2.常量成员函数:
	1. 只能对类成员只读,不可写

operator 运算符重载:
可重载的运算符:
	双目算术运算符 	+ (加)，-(减)，*(乘)，/(除)，% (取模)
	关系运算符 	==(等于)，!= (不等于)，< (小于)，> (大于)，<=(小于等于)，>=(大于等于)
	逻辑运算符 	||(逻辑或)，&&(逻辑与)，!(逻辑非)
	单目运算符 	+ (正)，-(负)，*(指针)，&(取地址)
	自增自减运算符 	++(自增)，--(自减)	如果是后置需要用到占位符 -> 函数占位参数
	位运算符 	| (按位或)，& (按位与)，~(按位取反)，^(按位异或)，<< (左移)，>>(右移)
	赋值运算符 	=, +=, -=, *=, /= , % = , &=, |=, ^=, <<=, >>=
	空间申请与释放 	new, delete, new[ ] , delete[]
	其他运算符 	()(函数调用)，->(成员访问)，,(逗号)，[](下标)

不可重载的运算符:
	 .：成员访问运算符
	 .*, ->*：成员指针访问运算符
    	 ::：域运算符
    	 sizeof：长度运算符
    	 ?:：条件运算符
    	 #： 预处理符号

friend友元: 打破封装,可以访问类中所有的成员
	1.友元函数
	2.友元类
	3.友元类函数


/**** 继承 ****/
方式： 1.单继承   2.多继承
问题:
       1. 菱形继承 -> 虚继承
       2. 成员重名 -> 域

/**** 多态 ****/
方式: 必须有继承关系，而且父类函数使用了 虚函数,子类重写这个 虚函数,在调用的时候产生不同结果
	1. 调用方式： 虚函数表
		1.父类指针指向子类对象
		2.父类引用指向子类对象
		问题：为什么不用子类指针指向父类对象呢?
			答:子类空间通常大于父类,可能会照成访问越界,所以C++编译器做了放置该操作

虚函数 -> 纯虚函数 -> 抽象类(无法实例化,必须由子类继承并且实现该纯虚函数,实现纯虚函数的子类才可进行实例化对象)


/***************** STM32 裸机编程 ************************/
由于我们编程通常使用C语言编程，因为C语言需要堆栈支持,所以需要CPU内存里拥有堆栈
         汇编语言可以直接对应寄存器,所以它可以去开创C语言需要的环境
     1. 启动文件讲解 -> 堆栈申请 , 中断函数向量表的弱化 [WEAK]  弱函数 ，优先调用强函数,当没有强函数的时候就调用弱函数
	用户需要用C语言写 SystemInit 和 main 函数
     2. GPIO的控制(根据开发手册 , 使能时钟 , 配置引脚的功能)
     3. 系统时钟的讲解
     4. UART串口通讯(异步,同步)      工作方式:异步全双工(波特率)
     5. 中断系统(UART接收中断,按键中断)
     6. IIC 通讯 ( 起始信号 , 停止信号 , 中间传输数据时序 ,  应答 , 非应答 ) , 它支持 多主机通讯 , 设备地址 7(普遍) 或 10 位(少有)设备地址，所以支持 128 个设备 
	地址访问的时候最低位用于表示 收还是发
	工作方式:  同步半双工(数据线,时钟线)
     7. SPI 通讯支持单主机通讯, 工作方式: 同步全双工 (数据线*2,时钟线*1)
     8. 模块讲解 ( dht11 温湿度模块 , 光敏模块 )

/***************** Linux 系统移植 ******************************/
1.BootLoader -> Uboot 启动 (堆栈,中断,模块)
2.内核 -> 内核裁剪 
3.根文件系统 -> 制作系统索要的环境(系统调用索要的程序和配置)

/***************** Linux 驱动开发 *******************************/
1. 为应用层提供访问底层的接口 open , close , read , write , ioctl 
2. 字符设备框架  ->  字符设备开发(开发中大多使用字符设备)
3. LED , PWM , ADC ，摄像头驱动 V4L2框架
4. 网卡驱动

      
     
     
关于单片机的部分
TTL（全双工通信）
RS232（全双工，常用于mcu与pc）
RS485（半双工）
SPI(同步串行)











       