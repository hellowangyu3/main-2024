/***********************************
 * 创建进程的三大方式：
 * 1.fork()和vfork()函数
 * 2.exec()函数族,代码替换
 * 3.system()函数
 * *******************************/

/************ fork() Vs  vfork() *********************************
 * 说明：子进程会完全拷贝父进程的所有资源，除了PCB控制块(pid,等等数据)，文件描述符表也会拷贝
 *      所以，物理空间地址不同，两个进程的变量改变不会受到影响。（问题：进程间如何通讯？）
 * 函数名1:pid_t fork(void);
 * 函数名2:pid_t vfork(void);
 * 功能：创建子进程
 *      fork父子进程运行随机
 *      vfork子进程先运行,直到子进程结束或者调用exec函数族之后才运行父进程。
 * 参数:无
 * 返回值：pid_t 返回子进程号
 *     =0:子进程  
 *     >0:父进程
 *     <0:创建失败
 * ****************************************************************/
/********* 进程结束状态 ************************************************************
 * 1.父进程先于子进程结束（官方:子进程的资源必须由父进程回收）(找爸爸)
 *      答：现在的子进程变成孤儿进程，寻找(1号进程)init进程作为父进程或者(1号进程的托管进程)
 * 2.当子进程先于父进程结束（官方:子进程的资源必须由父进程回收）(打僵尸)
 *      答：现在的子进程编程僵尸进程，进程结束不会释放PCB必须由父进程回收，父进程回收子进程的PCB
 *         使用wait()或者waitpid()函数为其收尸
 * *******************************************************************************/

/**************** wait() Vs waitpid() ***********************
 * 函数名1：pid_t wait(int *status);
 * 函数名2：pid_t waitpid(pid_t pid, int *status, int options);
 * 功能：回收子进程资源，wait()阻塞式回收，waitpid()既可以阻塞也可非阻塞比较灵活
 * 参数：
 *      int *status：用于存储子进程返回的状态码,NULL就是不接收状态
 *      pid_t pid： 
 *              < -1 :表示等待进程组ID为的子进程
 *              = -1 :表示等待任何子进程
 *              = 0  :表示等待进程组的进程
 *              > 0  :表示指定回收某进程
 *      options：
 *              WNOHANG ：非阻塞，如果成功返回 >0 的pid，如果子进程没有结束立马返回:0
 *              WUNTRACED:非追踪式回收
 *              0：阻塞式回收
 * 返回值：
 *      成功：返回 >0 的pid
 *      非阻塞:返回 =0 
 *      失败: 返回 -1     
 * ********************************************************/

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>

int main()
{
    /***** 1.创建子进程 ******/
    pid_t pid = fork();

    /***** 2.判断子进程返回的进程号 *****/
    if (pid < 0)
    {
        /***** <0:创建失败 *****/
        printf("创建进程失败\n");
    }
    else if (pid == 0)
    {
        /***** =0:子进程  *****/
        while (1)
        {
            //获取当前进程的的进程号 getpid(),获取当前进程的父进程号 getppid()
            printf("子进程的pid号:%d,子进程的父进程的pid：%d,pid = %d\n", getpid(), getppid(), pid);
            sleep(1);
        }
        exit(0);
    }
    else
    {
#if 0
        /***** >0:父进程  *****/
        while (1)
        {
            //获取当前进程的的进程号 getpid(),获取当前进程的父进程号 getppid()
            printf("父进程的pid号:%d,父进程的父进程的pid：%d,pid = %d\n", getpid(), getppid(),pid);
            sleep(1);
        }
#else
        printf("父进程的pid号:%d,父进程的父进程的pid：%d,pid = %d\n", getpid(), getppid(), pid);

        // wait(NULL); //死等(阻塞)

        // while(waitpid(-1,NULL,WNOHANG) == 0)    // =0 的时候，子进程没有结束
        // {
        //     printf("子进程依旧活着\n");
        //     sleep(1);
        // }

        waitpid(-1,NULL,0); //相当于    wait(NULL); //死等(阻塞)
        
        printf("父进程结束\n");
#endif
        exit(0);
    }
}
